/**
*@mainpage Библиотека работы с кольцом многочленов над кольцом вычетов из q элементов.
*@author Шурыгин Дмитрий Михайлович, 318 ВМК МГУ, 2017
*/

#ifndef FIELDVEC_H
#define FIELDVEC_H

#include <vector>
#include <iostream>

/**
* Класс, используемый для того, чтобы показать тип исключения "кольцо вычетов по модулю 0"
*/
class NullField{};

/**
* OneField - Класс, используемый для того, чтобы показать тип исключения "кольцо вычетов по модулю 1"
*/
class OneField{};

/**
* Класс, используемый для того, чтобы показать тип исключения "не является полем вычетом"
*/
class NotPrimal{};

/**
* Класс, используемый для того, чтобы показать тип исключения "деление на 0"
*/
class DivisionOnZero{};


/**
* Основной класс. Реализует работу с кольцом многочленов над кольцом вычетов из q элементов
*/
class FieldVec{

public:

    /**
    * @var q статическая переменная. Возможна работа только с кольцом полиномов только над кольцом вычетов по одному модулю.
    * В начале программы явным образом должно быть прописано 
    * FieldVec::q = <Количество элементов кольца вычетов>; (без <>)
    * Программа может некорректно обрабатывать старые векторы при изменении q
    */
    static unsigned int q;
    
    /**
    * @function FieldVec(void) Конструктор. При таком создании полином представляется в виде 0 * x ^ 0
    * @throw NullField если при инициализации первой переменной класса FieldVec было подано значение p == 0
    * @throw OneField если при инициализации первой переменной класса FieldVec было подано значение p == 1
    */
    FieldVec(void);

    /**
    * @function FieldVec(std::vector<unsigned int> v) Конструктор. Если в векторе v нет элементов, то полином представляется в виде 0 * x ^ 0,
    * иначе - коэффициентом при x^i будет v[i] 
    * @param[in] v Вектор коэффициентов. В v[i] коэффициент при x^i.
    * @throw NullField Если при инициализации первой переменной класса FieldVec было подано значение p == 0
    * @throw OneField Если при инициализации первой переменной класса FieldVec было подано значение p == 1
    */
    FieldVec(std::vector<unsigned int> &v);


    FieldVec(FieldVec const &v);

    /**
    * @function push_back(unsigned int t) Функция расширения вектора коэффициентов полинома.
    * @param[in] t Если хранится полином с максимальной степенью s (перед которой коэффициент, возможно, равен 0), то
    * к этому полиному добавляется t * q ^ (s + 1).
    */
    void push_back(const unsigned int &t);
    /**
    * @function size Показывает, сколько элементов находится в векторе коэффициентов
    * @return Максимальная степень x в этом многочлене (перед которой коэффициент, возможно, равен 0)
    */
    int size() const;

    /**
    * @param[in] t Степень монома x ^ t
    * @return lvalue коэффициент при x ^ t в полиноме. Если максимальная степень s (перед которой коэффициент, возможно, равен 0)
    *и s < t, то максимальная степень становиться равна t, а кожффициент при ней - 0.
    */
    unsigned int &operator[](const unsigned int &t);

    /**
    * @function operator+ Оператор сложения полиномов в кольце полиномов над кольцом вычетов по модулю q
    */
    FieldVec operator+(const FieldVec &v);
    /**
    * @function operator+= Оператор сложения полиномов в кольце полиномов над кольцом вычетов по модулю q
    */
    FieldVec &operator+=(const FieldVec &v);

    /**
    * @function operator* Оператор умножения полиномов в кольце полиномов над кольцом вычетов по модулю q
    */
    FieldVec operator*(const FieldVec &v);

    /**
    * @function operator*= Оператор умножения полиномов в кольце полиномов над кольцом вычетов по модулю q
    */
    FieldVec &operator*=(const FieldVec &v);

    /**
    * @function operator== Оператор сравнение полиномов на равенство в кольце полиномов над кольцом вычетов по модулю q
    */
    bool operator==(const FieldVec &v);


    FieldVec operator-();

    FieldVec operator-(const FieldVec &v);

    FieldVec &operator-=(const FieldVec &v);


    /**
    * @function operator% Оператор вычисления остатка от деления полиномов в кольце полиномов над полем вычетов по модулю q
    * @throw NotPrimal если q - не простое число (в данном случае если коэффициент при наивысшей степени x является делителем q и
    * при этом не равен q)
    * @throw DivisionOnZero если v - вектор, состоящий из 0
    * @return остаток от деления на полином v
    */
    FieldVec operator%(const FieldVec &v);

    /**
    * @function operator/ Оператор вычисления результата деления полиномов в кольце полиномов над полем вычетов по модулю q
    * @throw NotPrimal если q - не простое число
    * @throw DivisionOnZero если v - вектор, состоящий из 0
    * @return результат деления на полином v
    */
    FieldVec operator/(FieldVec &v);

    friend std::ostream& operator<<(std::ostream &os, const FieldVec &v){
        os << "(";
        for(int i = 0; i < v.size() - 1; i++){
            os << v.var[i] << ";";
        }
        os << v.var[v.size() - 1];
        os << ")";
        return os;
    }

    /**
    * @function tex_print
    * @brief Вывод полинома наподобие формулы LaTeX.
    * 
    * 
    * @param[in] std::ostream &os - поток вывода
    * @param[in] char *name - имя переменной (по умолчанию "x")
    *
    * ##Пример использования 1:
    *
    * Пусть q == 5, а в переменной FieldVec p хранится вектор коэффициентов
    * @code
    * (0;2;1;3;2;3)
    * @endcode
    * Тогда в результате выполнения команды
    * @code
    * p.tex_print(std::cout);
    * @endcode
    * на стандартный поток вывода поступит
    * @code
    * 3 x ^ { 5 } + 2 x ^ { 4 } + 3 x ^ { 3 } + x ^ { 2 } + 2 x 
    * @endcode
    *
    * И сама формула выглядит так:
    * \f[3 x ^ { 5 } + 2 x ^ { 4 } + 3 x ^ { 3 } + x ^ { 2 } + 2 x \f]
    *
    * ##Пример использования 2:
    *
    * Пусть q == 4, в переменной FieldVec p хранится вектор коэффициентов
    * @code
    * (2;3;1)
    * @endcode
    * а в переменной r хранится вектор коэффициентов
    * @code
    * (3;2;1)
    * @endcode
    * Тогда в результате выполнения команды
    * @code
    * (p * r).tex_print(std::cout, "v_{12}");
    * @endcode
    * на стандартный поток вывода поступит
    * @code
    * v_{12} ^ { 4 } + v_{12} ^ { 3 } + 3 v_{12} ^ { 2 } + v_{12} + 2
    * @endcode
    *
    * И сама формула выглядит так:
    * \f[v_{12} ^ { 4 } + v_{12} ^ { 3 } + 3 v_{12} ^ { 2 } + v_{12} + 2 \f]
    */
    void tex_print(std::ostream &os, const char *name = "x");

private:
    /**
    * @var var - вектор коэффициентов. var[i] - коэффициент при x^i
    * Если не было явного объявления коэффициентов вектора, то в var лежит ровно одно значение:
    * var[0] == 0
    */
    std::vector<unsigned int> var;
    
};

#endif /*FIELDVEC_H*/